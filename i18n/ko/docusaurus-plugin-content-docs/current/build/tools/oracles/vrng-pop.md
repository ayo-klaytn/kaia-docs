# 검증 난수 생성기(vRNG)

![](/img/banners/kaia-pop.png)

이 문서는 제공된 카이아와의 통합을 위해 설계된 [Proof of Play](https://proofofplay.com)의 검증 난수 생성기(vRNG) 가이드의 개요를 제공합니다. vRNG 시스템은 [drand](https://drand.love/) 무작위성 비콘을 활용하여 안전하고 검증 가능한 난수를 카이아 블록체인의 스마트 컨트랙트에 전달합니다.

검증된 난수 생성기(vRNG)는 애플리케이션 지연을 최소화하기 위해 지연 시간이 짧은 난수 전송에 최적화되어 있습니다. 안정성과 확장성에 중점을 두고 설계되었습니다.

![](/img/build/tools/pop-vrng-overview.png)

## 등록

얼리 액세스 기간 동안에는 인증된 난수 생성기 시스템의 모든 사용자를 수동으로 등록해야 합니다. 이를 사용하려면 계약 주소가 **승인**되어야 하며, 그렇지 않으면 모든 요청이 취소됩니다.

:::info

팀은 [공식 양식](https://www.google.com/url?q=https://z7a9jnrajv8.typeform.com/to/Ywh9xVFF&sa=D&source=docs&ust=1756704565685312&usg=AOvVaw30-Ht88-ez_rKT6_-TmRX2)을 통해 제출하거나 Kaia 팀에 직접 연락하여 승인을 요청할 수 있으며, 어느 옵션이 더 편리한지 선택할 수 있습니다.

:::

## vRNG 계약 주소

| 네트워크      | 주소                                                                                                                                                       | API URL                                                                                                                                          |
| --------- | -------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------ |
| 카이아 메인넷   | [0xf628f7843d94064c5072704a53b9ec455bcc4abb](https://kaiascan.io/ko/address/0xf628f7843d94064c5072704a53b9ec455bcc4abb?tabId=txList&page=1)        | [https://vrf.proofofplay.com/v1](https://vrf.proofofplay.com/v1)                                 |
| 카이로스 테스트넷 | [0xd14d984603b0b7ade91be52f3fc4a917dfa77bcd](https://kairos.kaiascan.io/ko/address/0xd14d984603b0b7ade91be52f3fc4a917dfa77bcd?tabId=txList&page=1) | [https://staging.vrf.proofofplay.com/v1](https://staging.vrf.proofofplay.com/v1) |

## 사용법

### 난수 요청하기

다음 인터페이스는 난수를 요청하는 방법을 제공합니다.

컨트랙트는 각 체인에 배포된 VRFSystem을 호출할 수 있습니다. 선택적으로 각 이벤트에 주석이 추가되는 traceId를 제공할 수 있습니다(여러 단계를 수행하는 하나의 트랜잭션이 있는 경우 유용하며, 사용자는 체인에서 트랜잭션을 추적할 수 있습니다). 이 값은 \*\*필수 항목이 아니며 0으로 남겨둘 수 있습니다.

```solidity
// SPDX-License-Identifier: MIT LICENSE

pragma solidity ^0.8.26;

uint256 constant ID = uint256(keccak256('com.proofofplay.vrfsystem.v1'));

interface IVRFSystem {  
  /**  
   * Starts a VRF random number request  
   *  
   * @param traceId Optional ID to use when tracing the request  
   * @return requestId for the random number, will be passed to the callback contract  
   */  
  function requestRandomNumberWithTraceId(uint256 traceId) external returns (uint256);  
}

```

### 난수 콜백

요청된 모든 난수는 드랜드에서 첫 번째 번호를 전달할 수 있는 즉시 전달됩니다. 3초 정도 걸릴 수 있습니다.

:::note

첫 번째 요청ForRandomNumber가 제출된 **후**에 첫 번째 번호로 전화가 전달됩니다. 이렇게 하면 사용자가 난수를 요청하기 전에는 해당 번호를 알 수 없게 됩니다.

:::

```solidity
// SPDX-License-Identifier: MIT LICENSE

pragma solidity ^0.8.26;

interface IVRFSystemCallback {  
  /**  
   * Callback for when a Random Number is delivered  
   *  
   * @param requestId     Id of the request  
   * @param randomNumber   Random number that was generated by the Verified Random Number Generator Tool  
   */  
  function randomNumberCallback(uint256 requestId, uint256 randomNumber) external;  
}

```

#### 동일한 3초 창에 다른 숫자를 표시하려면 어떻게 해야 하나요?

기본적으로 드랜드는 모든 요청에 동일한 3초 이내에 동일한 번호를 전달합니다. 이 방법은 검증할 수 있어 좋지만, 이 기간 동안 사용자가 모두 다른 숫자를 갖도록 하려면 엔트로피 소스를 추가하는 것이 좋습니다.

다음은 거래당 고유한 난수를 사용하는 몇 가지 예시입니다.

```solidity
// Add the requestId (Most Gas Efficient)  
uint256 newRandomNumber = requestId + randomNumber;

// Hash with requestId  
uint256 newRandomNumber = uint256(keccak256(abi.encodePacked(requestId, randomNumber)

// More expensive, but more normalized, hash based on requestId in last 256 block hashes  
uint256 newRandomNumber = uint256(keccak256(abi.encodePacked(blockhash(block.number - (requestId % 256)), randomNumber))  
```

:::note

정규화가 보장되지는 않지만 위의 무작위성 속성은 유지됩니다. 원하는 대로 조정하여 어느 정도 정규화할 것을 권장합니다(예를 들어, 무작위 숫자에 sequenceId를 추가하면 매우 왜곡된 반면, 블록해시를 사용하면 매우 정규화된 결과를 얻을 수 있습니다).

:::

동일한 블록 내에서 다른 번호를 사용하려면 동일한 트랜잭션에서 동일한 번호를 여러 번 다시 해시하는 것을 권장합니다.

```solidity
functionThatUsesNumber(randomNumber);  
randomNumber = uint256(keccak256(randomNumber));  
functionThatUsesNumber(randomNumber);  
```

#### 동일한 거래에서 다른 번호를 사용하려면 어떻게 해야 하나요?

기본적으로 거래당 하나의 번호만 제공됩니다. 개발자는 이 숫자를 사용하여 다른 숫자를 도출하여 새로운 숫자를 만들 것을 권장합니다.

```solidity
//Example 1: Keccak derive  
uint256 randomNumber = 12398012938091283113928;  
uint256 randomNumber2 = keccak256(randomNumber);  
uint256 randomNumber3 = keccak256(randomNumber2);

//Example 2: Split the number and use both sides  
uint256 randomNumber = 234345234523452345;  
uint256 randomNumber2 = randomNumber >> 128;  // Take upper 128 bits  
uint256 randomNumber3 = randomNumber & ((1 << 128) - 1); // Take lower 128 bits  
```

### 블록체인 이벤트

계약은 다음과 같은 이벤트를 발생시킵니다.

```solidity
/// @notice Emitted when a random number request is initiated  
/// @param requestId The unique identifier for the random number request  
/// @param callbackAddress The address to which the random number is requested  
/// @param traceId The trace ID used to track the request across transactions (0 if no trace ID)  
event RandomNumberRequested(uint256 indexed requestId, address indexed callbackAddress, uint256 indexed traceId);

/// @notice Emitted when a random number is successfully delivered  
/// @param requestId The unique identifier of the fulfilled request  
/// @param callbackAddress the address was random number is requested to  
/// @param traceId The trace ID associated with the request  
/// @param number The round number that was used for the random number  
/// @param randomNumber The random number that was generated  
event RandomNumberDelivered(uint256 indexed requestId, address indexed callbackAddress, uint256 indexed traceId, uint256 roundNumber, uint256 randomNumber);

```

RPC 수준에서 이러한 이벤트를 쿼리하여 전달되었는지 확인하거나 블록 탐색기를 사용하여 이벤트 스트림을 볼 수 있습니다.

#### 랜덤으로 라운드 번호/난수 확인하기

난수를 확인하고 싶으시면 드랜드에서 직접 확인할 수 있습니다. 저희는 이를 위해 드랜드의 **퀵넷**을 사용합니다.

\*\*예를 들어, 라운드 번호 11:\*\*를 보려면 다음과 같이 하세요.

GET [https://api.drand.sh/52db9ba70e0cc0f6eaf7803dd07447a1f5477735fd3f661792ba94600c84e971/public/11](https://api.drand.sh/52db9ba70e0cc0f6eaf7803dd07447a1f5477735fd3f661792ba94600c84e971/public/11)

```json
{  
  "round": 11,  
  "randomness": "ebdcbfe855d10c56db22455fa5a18963c1f62d85f859c35c310273449b49d284",  
  "signature": "163d14081e191a3f5d81e2f580eab591ea608402fda4f6e44b5a0bde11e368070e77d07ad3240726ea33e410c84d4b09ea0a4a0291f6c3c485d8630e1c0edf0a"  
}  
```

여기서 16진수의 난수는 `ebdcbfe855d10c56db22455fa5a18963c1f62d85f859c35c310273449b49d284`임을 알 수 있습니다.

### EIP712 서명을 사용한 수동 재시도

:::info

**이 기능은 미리 보기 중입니다**. 이 기능을 사용하려면 Kaia 팀에 문의하세요.

:::

매우 드물게 난수가 전달되지 않는 경우가 있을 수 있습니다. 대부분의 경우 이는 계약 측의 문제입니다.

이러한 상황에서는 이 번호를 직접 전달하도록 선택할 수 있습니다. 먼저 블록체인 상의 컨트랙트에 직접 난수를 전달하는 데 사용할 수 있는 EIP712 서명을 API 서버에 요청해야 합니다.

**요청:**

```javascript
GET https://vrf.proofofplay.com/v1/vrf/{chainId}/{txHash}  
```

**응답:**

```javascript
{  
  "requestId": Number,  
  "roundNumber": Number,  
  "randomNumber": BigInt,  
  "signature": String // bytes data of signature  
}  
```

이제 응답을 통해 VRFSystem 컨트랙트를 호출할 수 있습니다.

```solidity
vrf.deliverSignedRandomNumber(requestId, roundNumber, randomNumber, signature);  
```

:::warning

일반적인 릴레이 흐름으로 레이스를 진행하게 됩니다. InvalidRequestId로 tx 리턴이 발생하면 릴레이가 이미 이 난수를 전달했다는 뜻입니다. 난수는 한 번만 전달할 수 있습니다.

:::