# 信頼できるトランザクションのためのNoncesの管理方法

KaiaやEVM互換のブロックチェーンで構築する場合、nonceの管理は、dAppを円滑に実行させるか、あるいはトランザクションの停滞や失敗を招く可能性のある、細部の1つである。 このガイドでは、noncesとは何か、なぜそれが重要なのか、そしてバルク・トランザクションやシーケンシャル・トランザクションを送信する際にnoncesを効果的に扱う方法について説明する。

## Nonceとは何か？

nonce（一度だけ使われる番号）は、アカウント（EOA）のトランザクション・カウンターである。 最初のトランザクションはnonce 0を使用する。 トランザクションは厳密な順序（0, 1, 2, …）で処理されなければならない。 この順序付けはリプレイを防ぎ、意図した実行順序を保証する。 ウォレットは通常、エンドユーザーのためにこれを管理するが、高スループットのシステムや料金委譲されたフローでは、しばしば明示的なコントロールが必要になる。

## よくあるノンスの問題

トランザクションが不正なnonce値で送信されると、いくつかの問題が発生する可能性がある：

### ノンシーケンスのギャップ

後のトランザクションは、欠落したnonceが満たされるのを待つために立ち往生する。 例えば、nonce 0、1、3（2はスキップ）でトランザクションを送信した場合、nonce 2が送信されるまで、トランザクション3以降は処理されない。

### 重複するノンス

同じnonceを持つ2つのトランザクションは競合する。 先に確定した方が勝ち。 もう一方は落とされる。

### 一括トランザクションの衝突

nonceの追跡を注意深く行わずに複数のトランザクションを素早く送信すると、nonceの競合のために、いくつかのトランザクションが失敗したりストールしたりすることがある。

## 一括トランザクションのためのNoncesの管理

多くのトランザクション（バッチ操作、NFTミント、アービトラージボット）を送信する場合、ウォレットの自動化だけに頼ることはできません。 システマティックなアプローチが必要だ。

### 1. オフチェーン・ノンス・ストアの維持

データストア(**Redis**、**Postgres**、またはインメモリマップ)を使用して、アカウントごとに次のnonceを追跡する。 セッションを開始するときは、`eth_getTransactionCount`を使用してブロックチェーンと同期する。 各トランザクションを送信した後、直ちにローカルのnonceカウンタをインクリメント する。

このアプローチは、nonceの割り当てを正確に制御し、トランザクションを連続して送信する際の競合を防ぐ。

### 2. 自動化のためにWeb3ライブラリを使用する

ethers.js**や**web3.js\*\*のようなライブラリは、逐次トランザクションのためのnonce割り当てを自動的に処理する。 一括トランザクションや並列トランザクションの場合は、nonceストアから手動でnonceを上書きする。

### 3. 複数アカウントでのトランザクションの並列化

トランザクションが独立している場合は、複数のEOAに分散させる。 例えば、1つのアカウントが100のトランザクションを送信する（nonceのボトルネックになる）代わりに、10個のアカウントがそれぞれ10を送信するようにする。 これにより、スループットが大幅に向上する。

### 4. 堅牢なエラー処理の実装

トランザクションのドロップやスタックを検出する（多くの場合、ガスが少ないことが原因）。 その代わり、ガソリン代が高くなる。 このプロセスは "スピードアップ "として知られ、トランザクション・キューが動き続けることを保証する。

本番環境では、リトライロジックが重要である。 一時的な障害を処理し、必要に応じてトランザクションを再送信する仕組みを構築する。

### 5. ブロックチェーン・エクスプローラーによるモニター

KaiaScan\*\*、**OKX Explorer**、またはカスタムインデクサーなどのツールを使用して、nonceの進行を検証する。 これは、トランザクションの伝播に失敗したり、予期しない状態に陥ったりした場合のデバッグに役立つ。

### 6. 拡張性を考慮した設計

高スループットのシステム（取引ボット、バッチミント）については、新しいEOAを動的に割り当て、ノンセキューを使用して順序を確保し、複数のアカウントにトランザクションを分散して水平方向に拡張するワークフローを設計する。

### 7. 上級者向けの手動調整

トランザクションがスタックした場合に、noncesを手動で設定するオプションを提供する。 MetaMaskのような）ほとんどのウォレットは、きめ細かなコントロールを必要とするパワーユーザーのために、すでにこれをサポートしている。

## フロー例：一括トランザクション管理

ここでは、典型的なnonce管理システムがバルク・トランザクションでどのように機能するかを説明する：

![](/img/build/tutorials/nonce-management-example.png)

1. \*\*現在のnonceを取得する：nonceマネージャー（例えばRedis）に問い合わせて、送信者アドレスに最後に使用されたnonceを取得する。
2. **Incrementとassign**：ローカルでnonceをインクリメントし、次のトランザクションに割り当てる。
3. \*\*トランザクションを送信する：トランザクションをネットワークに送信する
4. \*\*ストアを更新する：送信者アドレスに基づいて、データストア（Redis、データベース）のnonceを直ちに更新する。
5. \*\*失敗を処理する：トランザクションが失敗した場合(例えばTx(1))、Tx(2)に進む前に、同じnonceを使用して、より高いガス料金で再試行ロジックを実装する。

重要なのは、アドレスごとに最後に使用されたnonceを追跡する集中型nonceマネージャーを維持することである。 各トランザクションはこの値をインクリメントし(Tx(0)はnonce 0を使用し、 Tx(1)はnonce 1を使用する、というように)、ストアをアトミックに更新する。 これにより、トランザクションを連続して送信する際のnonceの衝突を防ぐことができる。

ガスの上限と料金の見積もり（再試行時に高い料金を選択することも含む）については、[Kaia WalletとMetaMaskのガスの上限と料金の見積もり方法](../wallets/wallet-ops/estimate-gaslimits-prices-on-kaia-wallet-and-metamask.mdx)を参照してください。

## 結論

信頼性の高いnonce管理は、トランザクションの多いシステムには不可欠である。 高いスループットを維持し、ストールを回避するために、オフチェーン・ノンス・ストア、適切なエラー処理（同じノンス、高い料金）、モニタリング、水平スケーリングを使用する。 同じnonceルールが、料金委譲トランザクションにも適用される。