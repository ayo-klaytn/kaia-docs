# 検証済み乱数生成器 (vRNG)

![](/img/banners/kaia-pop.png)

このドキュメントは、[Proof of Play](https://proofofplay.com)による検証済み乱数生成器(Verified Random Number Generator: vRNG)ガイドの概要であり、Kaiaとの統合用に設計されています。 vRNGシステムは、[drand](https://drand.love/)乱数ビーコンを活用し、Kaiaブロックチェーン上のスマートコントラクトに安全で検証可能な乱数を提供する。

検証済み乱数生成器（vRNG）は、アプリケーションの遅延を最小限に抑えるため、乱数の低遅延配信に最適化されています。 信頼性と拡張性に重点を置いて設計されている。

![](/img/build/tools/pop-vrng-overview.png)

## 参加登録

早期アクセス期間中、検証済み乱数生成システムの利用者はすべて手動で登録する必要がある。 これを使用するためには、あなたの契約アドレスが承認されなければなりません。

:::info

チームは、[公式フォーム](https://www.google.com/url?q=https://z7a9jnrajv8.typeform.com/to/Ywh9xVFF&sa=D&source=docs&ust=1756704565685312&usg=AOvVaw30-Ht88-ez_rKT6_-TmRX2)から申請するか、カイアチームに直接連絡するか、どちらか都合の良い方法で承認を申請することができます。

:::

## vRNG契約アドレス

| ネットワーク      | 住所                                                                                                                                                       | API URL                                                                                                                                          |
| ----------- | -------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------ |
| カイア・メインネット  | [0xf628f7843d94064c5072704a53b9ec455bcc4abb](https://kaiascan.io/ko/address/0xf628f7843d94064c5072704a53b9ec455bcc4abb?tabId=txList&page=1)        | [https://vrf.proofofplay.com/v1](https://vrf.proofofplay.com/v1)                                 |
| カイロス・テストネット | [0xd14d984603b0b7ade91be52f3fc4a917dfa77bcd](https://kairos.kaiascan.io/ko/address/0xd14d984603b0b7ade91be52f3fc4a917dfa77bcd?tabId=txList&page=1) | [https://staging.vrf.proofofplay.com/v1](https://staging.vrf.proofofplay.com/v1) |

## 使用方法

### 乱数のリクエスト

以下のインターフェイスは乱数を要求するメソッドを提供する。

コントラクトは、各チェーンに配置されたVRFSystemを呼び出すことができます。 オプションでtraceIdを指定することができ、各イベントにアノテーションされます（1つのトランザクションが多くのステップを実行する場合、ユーザーはチェーン上のトランザクションをトレースすることができるので便利です）。 これは **必須** ではないので、0のままでよい。

```solidity
// SPDX-License-Identifier: MIT LICENSE

pragma solidity ^0.8.26;

uint256 constant ID = uint256(keccak256('com.proofofplay.vrfsystem.v1'));

interface IVRFSystem {  
  /**  
   * Starts a VRF random number request  
   *  
   * @param traceId Optional ID to use when tracing the request  
   * @return requestId for the random number, will be passed to the callback contract  
   */  
  function requestRandomNumberWithTraceId(uint256 traceId) external returns (uint256);  
}

```

### 乱数コールバック

要求されたすべての乱数は、drandからの最初の数字が配信可能になり次第、配信される。 これは3秒ほどかかることもある。

:::note

あなたの電話は、最初のリクエストForRandomNumberが送信された後、最初の番号が配信されます。 これにより、ユーザーが乱数を要求する前に、**乱数を知ることは**できない。

:::

```solidity
// SPDX-License-Identifier: MIT LICENSE

pragma solidity ^0.8.26;

interface IVRFSystemCallback {  
  /**  
   * Callback for when a Random Number is delivered  
   *  
   * @param requestId     Id of the request  
   * @param randomNumber   Random number that was generated by the Verified Random Number Generator Tool  
   */  
  function randomNumberCallback(uint256 requestId, uint256 randomNumber) external;  
}

```

#### 同じ3秒のウインドウに異なる数字を入れたい場合は？

デフォルトでは、drandが提供する同じ3秒のウィンドウ内で、すべてのリクエストに同じ数字を配信する。 しかし、この期間中にすべてのユーザーが異なる数字を持つようにしたい場合は、エントロピーのソースを追加することをお勧めします。

トランザクションごとにユニークな乱数を持つ例をいくつか紹介しよう。

```solidity
// Add the requestId (Most Gas Efficient)  
uint256 newRandomNumber = requestId + randomNumber;

// Hash with requestId  
uint256 newRandomNumber = uint256(keccak256(abi.encodePacked(requestId, randomNumber)

// More expensive, but more normalized, hash based on requestId in last 256 block hashes  
uint256 newRandomNumber = uint256(keccak256(abi.encodePacked(blockhash(block.number - (requestId % 256)), randomNumber))  
```

:::note

これらは正規化されることは保証されないが、上記のランダム性の特性は保持される。 多かれ少なかれ正規化されるように、お好みで調整することをお勧めする（例えば、randomNumberにsequenceIdを加えると非常に歪むが、ブロックハッシュを使えば非常に正規化される）。

:::

同じブロック内で異なる番号を使用したい場合は、同じトランザクション内で同じ番号を複数回ハッシュし直すことをお勧めします。

```solidity
functionThatUsesNumber(randomNumber);  
randomNumber = uint256(keccak256(randomNumber));  
functionThatUsesNumber(randomNumber);  
```

#### 同じ取引で異なる番号を使いたい場合は？

デフォルトでは、1回のお取引につき1つの番号のみが付与されます。 開発者には、この数字を使って他の数字を導き出し、新しい数字を作ることを奨励している。

```solidity
//Example 1: Keccak derive  
uint256 randomNumber = 12398012938091283113928;  
uint256 randomNumber2 = keccak256(randomNumber);  
uint256 randomNumber3 = keccak256(randomNumber2);

//Example 2: Split the number and use both sides  
uint256 randomNumber = 234345234523452345;  
uint256 randomNumber2 = randomNumber >> 128;  // Take upper 128 bits  
uint256 randomNumber3 = randomNumber & ((1 << 128) - 1); // Take lower 128 bits  
```

### ブロックチェーン・イベント

コントラクトは以下のイベントを発する。

```solidity
/// @notice Emitted when a random number request is initiated  
/// @param requestId The unique identifier for the random number request  
/// @param callbackAddress The address to which the random number is requested  
/// @param traceId The trace ID used to track the request across transactions (0 if no trace ID)  
event RandomNumberRequested(uint256 indexed requestId, address indexed callbackAddress, uint256 indexed traceId);

/// @notice Emitted when a random number is successfully delivered  
/// @param requestId The unique identifier of the fulfilled request  
/// @param callbackAddress the address was random number is requested to  
/// @param traceId The trace ID associated with the request  
/// @param number The round number that was used for the random number  
/// @param randomNumber The random number that was generated  
event RandomNumberDelivered(uint256 indexed requestId, address indexed callbackAddress, uint256 indexed traceId, uint256 roundNumber, uint256 randomNumber);

```

これらのイベントをRPCレベルで照会して、配信されたかどうかを確認したり、ブロック・エクスプローラーを使ってイベントのストリームを表示したりすることができる。

#### drandによるラウンド番号／乱数の検証

乱数を確認したい場合は、drandに直接確認することができる。 これにはdrandの**quicknet**を使っている。

**例えば、丸数字の11を見るには、**。

GET [https://api.drand.sh/52db9ba70e0cc0f6eaf7803dd07447a1f5477735fd3f661792ba94600c84e971/public/11](https://api.drand.sh/52db9ba70e0cc0f6eaf7803dd07447a1f5477735fd3f661792ba94600c84e971/public/11)

```json
{  
  "round": 11,  
  "randomness": "ebdcbfe855d10c56db22455fa5a18963c1f62d85f859c35c310273449b49d284",  
  "signature": "163d14081e191a3f5d81e2f580eab591ea608402fda4f6e44b5a0bde11e368070e77d07ad3240726ea33e410c84d4b09ea0a4a0291f6c3c485d8630e1c0edf0a"  
}  
```

16進数の乱数は `ebdcbfe855d10c56db22455fa5a18963c1f62d85f859c35c310273449b49d284` である。

### EIP712シグネチャによる手動再試行

:::info

\*\*この機能はプレビュー中です。 ご利用を希望される方は、カイアチームまでご連絡ください。

:::

ごくまれに乱数が配信されないことがあります。 ほとんどの場合、これは契約側の問題になる。

このような場合は、自分でこの番号を伝えることもできる。 まず、当社のAPIサーバーにEIP712署名をリクエストしてください。このAPIサーバーを使用して、ブロックチェーン上のコントラクトに直接乱数を配信することができます。

\*\*リクエスト

```javascript
GET https://vrf.proofofplay.com/v1/vrf/{chainId}/{txHash}  
```

**回答：**\*。

```javascript
{  
  "requestId": Number,  
  "roundNumber": Number,  
  "randomNumber": BigInt,  
  "signature": String // bytes data of signature  
}  
```

レスポンスがあれば、VRFSystemコントラクトを呼び出すことができる。

```solidity
vrf.deliverSignedRandomNumber(requestId, roundNumber, randomNumber, signature);  
```

:::warning

通常のリレーの流れでレースをすることになる。 InvalidRequestIdでtxがリバートされた場合、これはリレーがすでにこの乱数を配信したことを意味する。 乱数は一度しか配信できない。

:::